package main

import (
	"fmt"
	"sync"
)

// Создаем структуру Cache с полями:
type Cache struct {
	data map[string]string // data - это наша мапа где будут хранится данные
	mu   sync.RWMutex      // Наш любимый Mutex для эклюзивной блокировки данных
}

// Создаем метод Get(), который будет принимать ключ, смотреть есть ли записи по этому ключу и возваращать value
func (c *Cache) Get(key string) string {
	c.mu.RLock()         // Блокируем эклюзивный доступ к чтению данных
	defer c.mu.RUnlock() // Разблокируем эклюзивный доступ к чтению данных
	return c.data[key]   // Возвращаем наш ключ
}

// Создаем второй метод Set(), который будет в ключ записывать значение
func (c *Cache) Set(key string, val string) {
	c.mu.Lock()         // Блокируем эклюзивный доступ
	defer c.mu.Unlock() // Разблокируем эклюзивный доступ
	c.data[key] = val   // Записываем в ключ = значение
}
func main() {
	// Реализуем обьект
	Website := &Cache{
		data: make(map[string]string), // Data - при реализации обьекта будет пустая
	}

	wg := sync.WaitGroup{} // Используем WaitGroup для синхронизации горутин
	wg.Add(2)              // Добавляем в наш счетчик две задачи

	go func() {
		defer wg.Done() // После того как все отработает от счетчика отнимется еденица
		// Запускаем цикл на 5 иттераций
		for i := 0; i < 5; i++ {
			Website.Set("key", "Google") // 5 раз записываем ключ и значение
		}
	}()

	// Во второй горутине мы будет читать наш ключ и выводить значение
	go func() {
		defer wg.Done()
		// Запускаем цикл намного раз больше, чем записи
		for i := 0; i < 30; i++ {
			// Используем наш метод Get() для обьекта Website
			fmt.Println(Website.Get("key")) // То что лежит под ключом "key", будет выведено 30 раз
		}
	}()

	wg.Wait() // Ждем когда счетчик будет равен 0
}
