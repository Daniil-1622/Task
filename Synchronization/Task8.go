package main

import (
	"fmt"
	"math/rand"
	"sync"
)

// Создаю структуру Stats
// Которая имеет поля:
type Stats struct {
	mu       sync.Mutex // Mutex - эклюзивная блокировка
	requests int        // Запросы
	errors   int        // Ошибки
}

// Создаем метод RecordRequest() - который дословно переводится как Записать запрос
func (s *Stats) RecordRequest() {
	s.mu.Lock()         // Блокируем доступ
	defer s.mu.Unlock() // Разблокируем доступ
	s.requests += 1     // Добавляем к нашем запросам 1, иммитация работы
}

// Создаем метод RecordError() - который дословно переводится как Записать ошибку
func (s *Stats) RecordError() {
	s.mu.Lock()         // Блокируем доступ
	defer s.mu.Unlock() // Разблокируем доступ
	s.errors += 1       // Добавляем к нашем запросам 1, иммитация работы
}

func main() {
	// Обязательно синхроннизируем наши горутины
	wg := sync.WaitGroup{}
	a1 := &Stats{} // Создаем Обьект а1

	for i := 0; i < 20; i++ { // Делаем 20 иттераций
		wg.Add(1) // На каждую иттерацию добавляем одну задачу
		go func() {
			defer wg.Done()          // Говорим что в конце от счетчика wg.Add(1) он будет отнимать еденицу, каждый раз как входит в цикл
			random := rand.Intn(100) // Используем пакет rand для иммитации запросов с вероятностью 90% успех и 10% ошибка
			if random < 90 {         // Если наш рандом выдает число меньше 90, тогда использует метод RecordRequest(), который иммитирует зарос
				a1.RecordRequest()
			} else { // Иначе, тоесть оставшиеся 10%
				a1.RecordError() // Иммитирует ошибку
			}
		}()
	}
	wg.Wait()                                                  // Дальше ждем выполнения всех задач синхроннизации
	fmt.Printf("Запрос:%d, Ошибок:%d", a1.requests, a1.errors) // Выводим строку со статистикой
}
